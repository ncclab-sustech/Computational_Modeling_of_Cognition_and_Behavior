#dat <- read.csv(file="rt_data.csv") # uncomment this if you read in data
nsubj <- 30
nobs <- 20
q_p <- c(.1,.3,.5,.7,.9)
shift <- rnorm(nsubj, 250, 50)
scale <- rnorm(nsubj, 200, 50)
shape <- rnorm(nsubj, 2, 0.25)
params <- rbind(shift,scale,shape) # combine R objects by rows
print(rowMeans(params))
# generate data: draw data from shifted weibull distribution
# rows are participants, columns are observations
dat <- apply(params, 2, function(x) rweibull(nobs, shape=x[3], scale=x[2])+x[1] )
# calculate sample quantiles for each particpant
kk <- apply(dat, 2, function(x) quantile(x, probs=q_p))
## FITTING VIA QUANTILE AVERAGING
# average the quantiles
vinq <- rowMeans(kk)
# fit the shifted Weibull to averaged quantiles
weib_qdev <- function(x, q_emp, q_p){
if (any(x<=0)){
return(10000000)
}
q_pred <- qweibull(q_p,shape=x[3],scale=x[2])+x[1] # prediction
dev <- sqrt(mean((q_pred-q_emp)^2))                # discrepency
}
## FITTING Vincent averaging data
# fitting data by minimize weib_qdev function
res <- optim(c(225,225,1), function(x) weib_qdev(x, vinq, q_p))
print(res)
## FITTING Individual participants
weib_deviance <- function(x,rts){
if (any(x<=0) || any(rts<x[1])){
return(10000000)
}
likel <- dweibull(rts-x[1], shape=x[3], scale=x[2])  # likelihood
dev <- sum(-2*log(likel))                            # deviance
}
res <- apply(dat,2,function(a) optim(c(100,225,1), function(x) weib_deviance(x, a)))
# Extract parameter estimates and put in to a matrix
parest <- matrix(
unlist(lapply(res, function(x) x$par)),
ncol=3, byrow=TRUE)
print( colMeans(parest) ) # mean parameter estimates
print( apply(parest,2,sd) ) # SD of estimates
# note correlations between parameter estimates
#install.packages('mixtools')
#install.packages('ggplot2')
library("ggplot2")
# generate some data
set.seed(1540614451)
N <- 1000
pShort <- 0.3
genpars <- list( c(100,10), c(150,20) )
# we assume equal sampling probability for the three distributions
whichD <- sample(c(1,2), N, replace=TRUE, prob=c(pShort, 1-pShort))
dat <- sapply(whichD, function(x)
rnorm(1, genpars[[x]][1], genpars[[x]][2]))
# function needed in EM (Expectation-Maximization)
weighted.sd <- function(x,w,mu=mean(x)){
wvar <- sum(w*(x-mu)^2)/
sum(w)
return(sqrt(wvar))
}
# guess parameters
mu1 <- mean(dat,1)*0.8
mu2 <- mean(dat, 1)*1.2
sd1 <- sd(dat)
sd2 <- sd(dat)
ppi <- 0.5
oldppi <- 0
while (abs(ppi-oldppi)>.00001){
oldppi <- ppi
# E step
resp <- ppi*dnorm(dat,mu2,sd2)/
((1-ppi)*dnorm(dat,mu1,sd1) + ppi*dnorm(dat,mu2,sd2))
# M step
mu1 <- weighted.mean(dat,1-resp)
mu2 <- weighted.mean(dat,resp)
sd1 <- weighted.sd(dat,1-resp,mu1)
sd2 <- weighted.sd(dat,resp,mu2)
ppi <- mean(resp)
print(ppi)
}
df <- data.frame(rt=dat)
# plot figures with ggplot
#pdf(file="GMMexample.pdf", width=5, height=4)
ggplot(df, aes(x = rt)) +
geom_histogram(aes(y = ..density..),colour = "black", fill = "white",
binwidth = 3) +
stat_function(fun = function(k) (1-ppi)*dnorm(k,mu1,sd1)) +
stat_function(fun = function(k) ppi*dnorm(k,mu2,sd2)) +
xlab("RT (ms)") + ylab("Density")
#dev.off()
# mixtools for comparison
# library(mixtools) # you'll need to install this library
# myEM <- normalmixEM( dat, mu = c(1,4), sigma=c(sd(dat),sd(dat)))
#dat <- read.csv(file="rt_data.csv") # uncomment this if you read in data
nsubj <- 30
nobs <- 20
q_p <- c(.1,.3,.5,.7,.9)
shift <- rnorm(nsubj, 250, 50)
scale <- rnorm(nsubj, 200, 50)
shape <- rnorm(nsubj, 2, 0.25)
params <- rbind(shift,scale,shape) # combine R objects by rows
print(rowMeans(params))
# generate data: draw data from shifted weibull distribution
# rows are participants, columns are observations
dat <- apply(params, 2, function(x) rweibull(nobs, shape=x[3], scale=x[2])+x[1] )
#dat <- read.csv(file="rt_data.csv") # uncomment this if you read in data
nsubj <- 30
nobs <- 20
q_p <- c(.1,.3,.5,.7,.9)
shift <- rnorm(nsubj, 250, 50)
scale <- rnorm(nsubj, 200, 50)
shape <- rnorm(nsubj, 2, 0.25)
params <- rbind(shift,scale,shape) # combine R objects by rows
print(rowMeans(params))
# generate data: draw data from shifted weibull distribution
# rows are participants, columns are observations
dat <- apply(params, 2, function(x) rweibull(nobs, shape=x[3], scale=x[2])+x[1] )
View(dat)
# calculate sample quantiles for each particpant
kk <- apply(dat, 2, function(x) quantile(x, probs=q_p))
View(kk)
View(kk)
## FITTING VIA QUANTILE AVERAGING
# average the quantiles
vinq <- rowMeans(kk)
View(kk)
vinq
library("ggplot2")
# generate some data
set.seed(1540614451)
N <- 1000
pShort <- 0.3
genpars <- list( c(100,10), c(150,20) )
# we assume equal sampling probability for the three distributions
whichD <- sample(c(1,2), N, replace=TRUE, prob=c(pShort, 1-pShort))
dat <- sapply(whichD, function(x)
rnorm(1, genpars[[x]][1], genpars[[x]][2]))
# function needed in EM (Expectation-Maximization)
weighted.sd <- function(x,w,mu=mean(x)){
wvar <- sum(w*(x-mu)^2)/
sum(w)
return(sqrt(wvar))
}
# guess parameters
mu1 <- mean(dat,1)*0.8
mu2 <- mean(dat, 1)*1.2
sd1 <- sd(dat)
sd2 <- sd(dat)
ppi <- 0.5
oldppi <- 0
# guess parameters
mu1 <- mean(dat,1)*0.8
mu2 <- mean(dat, 1)*1.2
sd1 <- sd(dat)
sd2 <- sd(dat)
ppi <- 0.5
oldppi <- 0
while (abs(ppi-oldppi)>.00001){
oldppi <- ppi
# E step
resp <- ppi*dnorm(dat,mu2,sd2)/
((1-ppi)*dnorm(dat,mu1,sd1) + ppi*dnorm(dat,mu2,sd2))
# M step
mu1 <- weighted.mean(dat,1-resp)
mu2 <- weighted.mean(dat,resp)
sd1 <- weighted.sd(dat,1-resp,mu1)
sd2 <- weighted.sd(dat,resp,mu2)
ppi <- mean(resp)
print(ppi)
}
df <- data.frame(rt=dat)
# plot figures with ggplot
#pdf(file="GMMexample.pdf", width=5, height=4)
ggplot(df, aes(x = rt)) +
geom_histogram(aes(y = ..density..),colour = "black", fill = "white",
binwidth = 3) +
stat_function(fun = function(k) (1-ppi)*dnorm(k,mu1,sd1)) +
stat_function(fun = function(k) ppi*dnorm(k,mu2,sd2)) +
xlab("RT (ms)") + ylab("Density")
#dev.off()
# Read in the data
# Rows are participants, columns are serial positions
# spcdat <- read.table("freeAccuracy.txt")
# Or generate some example data
nPrim <- 25
nRec <- 50
nBoth <- 25
ll <- 12
serpos <- 1:ll
nTrials <- 10
primDat <- matrix(rep(0,ll*nPrim),nPrim,ll)
for (j in 1:nPrim){
asym <- 0.3
expp <- 1
tdat <- (1-asym)*exp(-expp*(serpos-1)) + asym
primDat[j,] <- rbinom(n=ll,size=nTrials,prob=tdat)/nTrials
}
recDat <- matrix(rep(0,ll*nRec),nRec,ll)
for (j in 1:nRec){
asym <- 0.3
expp <- 1
tdat <- (1-asym)*exp(-expp*rev(serpos-1)) + asym
recDat[j,] <- rbinom(n=ll,size=nTrials,prob=tdat)/nTrials
}
bothDat <- matrix(rep(0,ll*nBoth),nBoth,ll)
for (j in 1:nBoth){
asym <- 0.5
expp <- 1
pc <- 0.5 * exp(-expp*rev(serpos-1)) + 0.5 * exp(-expp*(serpos-1))
tdat <- (1-asym)*pc + asym
bothDat[j,] <- rbinom(n=ll,size=nTrials,prob=tdat)/nTrials
}
spcdat <- rbind(primDat,recDat,bothDat)
#------------------------------------------
#pdf(file="gap_plot.pdf", width=4, height=4)
par(mfrow=c(1,1))
#install.packages('cluster')
library(cluster) # using package 'cluster'
gskmn <- clusGap(spcdat, FUN = kmeans, nstart = 20, K.max = 8, B=500)
plot(gskmn, ylim=c(0.15, 0.5))
#dev.off()
#-------------------------------------------
#pdf(file="kmeansSPC.pdf", width=8, height=4)
par(mfrow=c(1,2))
plot(colMeans(spcdat), ylim=c(0,1), type="b",
xlab="Serial Position", ylab="Proportion Correct", main=NULL)
kmres <- kmeans(spcdat, centers=3, nstart=10) #* \label{line:MultipleParticipants:runkmeans}  *\#
matplot(t(kmres$centers), type="b", ylim=c(0,1),
xlab="Serial Position", ylab="Proportion Correct")
#dev.off()
# kk <- {}
#
# for (nClust in 2:7){
#   kmres <- kmeans(spcdat, centers=nClust, nstart=10)
#   #kk <- c(kk, kmres$betweenss/kmres$totss)
#   kk <- c(kk,kmres$tot.withinss)
# }
#plot(2:7, kk, type="b", xlab="N Clusters", ylab="")
?rweibull
#dat <- read.csv(file="rt_data.csv") # uncomment this if you read in data
nsubj <- 30
nobs <- 20
q_p <- c(.1,.3,.5,.7,.9)
shift <- rnorm(nsubj, 250, 50)
scale <- rnorm(nsubj, 200, 50)
shape <- rnorm(nsubj, 2, 0.25)
params <- rbind(shift,scale,shape) # combine R objects by rows
print(rowMeans(params))
dat <- apply(params, 2, function(x) rweibull(nobs, shape=x[3], scale=x[2])  )
View(dat)
