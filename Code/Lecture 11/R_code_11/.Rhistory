drift <- -0.02        # noninformative stimulus
sdrw <- 0.3          # s.t.d in the evidence
criterion <- 3      # distance between boundary and baseline
latencies <- rep (0, nreps)  # a vector to store the simulated response latencies
responses <- rep (0, nreps)  # a vector to store the simulated responses
evidence <- matrix (0, nreps, nsamples+1)  # a matrix to store the evidence for each response
for (i in c(1:nreps)) {
evidence[i ,] <- cumsum ( c ( 0 , rnorm ( nsamples , drift , sdrw ) ) )
p <- which ( abs (evidence[i, ] ) >= criterion) [1]   # find the first evidence bigger than criterion
responses[i] <- sign (evidence[i,p])    # responses: positive (left) or negative (right)
latencies[i] <- p                       # response latency
}
mean( latencies[ c(responses==-1) ] )
mean( latencies[ c(responses==-1) ] )
## plot up to 5 random-walk paths
tbpn <- min(nreps, 5)
plot(1:max(latencies[1:tbpn])+10, type='n', las = 1,
ylim = c(-criterion, criterion),
ylab = 'Evidence', xlab='Decision time')
for (i in c(1:tbpn)){
lines(evidence[i, 1:(latencies[i])])
}
abline(h=c(criterion, -criterion), lty='dashed')
## plot histograms of latencies
par(mfrow=c(2 , 1))   # to set graphical parameters (2 subplot)
toprt <- latencies[responses>0]   # response time for the left response
topprop <- length(toprt)/nreps    # probability to choose the left response
hist(toprt, col='gray',
xlab='Decision time', xlim=c(0,max(latencies)),
main=paste('Top responses (', as.numeric(topprop),')m=', as.character(signif(mean(toprt),4)),
sep=''),las=1)   # plot the historgram
botrt <- latencies[responses<0]
botprop <- length(botrt)/nreps
hist(botrt,col="gray",
xlab="Decision time",xlim=c(0,max(latencies)),
main=paste("Bottom responses (",as.numeric(botprop),
") m=",as.character(signif(mean(botrt),4)),
sep=""),las=1)
## plot up to 5 random-walk paths
par(mfrow=c(1 , 1))
tbpn <- min(nreps, 5)
plot(1:max(latencies[1:tbpn])+10, type='n', las = 1,
ylim = c(-criterion, criterion),
ylab = 'Evidence', xlab='Decision time')
for (i in c(1:tbpn)){
lines(evidence[i, 1:(latencies[i])])
}
abline(h=c(criterion, -criterion), lty='dashed')
# random-walk model
nreps <- 2000    # number of trials
nsamples <- 2000  # samples to collect evidence for each decision
drift <- 0.02        # noninformative stimulus
sdrw <- 0.1          # s.t.d in the evidence
criterion <- 3      # distance between boundary and baseline
latencies <- rep (0, nreps)  # a vector to store the simulated response latencies
responses <- rep (0, nreps)  # a vector to store the simulated responses
evidence <- matrix (0, nreps, nsamples+1)  # a matrix to store the evidence for each response
for (i in c(1:nreps)) {
evidence[i ,] <- cumsum ( c ( 0 , rnorm ( nsamples , drift , sdrw ) ) )
p <- which ( abs (evidence[i, ] ) >= criterion) [1]   # find the first evidence bigger than criterion
responses[i] <- sign (evidence[i,p])    # responses: positive (left) or negative (right)
latencies[i] <- p                       # response latency
}
## plot up to 5 random-walk paths
par(mfrow=c(1 , 1))
tbpn <- min(nreps, 5)
plot(1:max(latencies[1:tbpn])+10, type='n', las = 1,
ylim = c(-criterion, criterion),
ylab = 'Evidence', xlab='Decision time')
for (i in c(1:tbpn)){
lines(evidence[i, 1:(latencies[i])])
}
abline(h=c(criterion, -criterion), lty='dashed')
## plot histograms of latencies
par(mfrow=c(2 , 1))   # to set graphical parameters (2 subplot)
toprt <- latencies[responses>0]   # response time for the left response
topprop <- length(toprt)/nreps    # probability to choose the left response
hist(toprt, col='gray',
xlab='Decision time', xlim=c(0,max(latencies)),
main=paste('Top responses (', as.numeric(topprop),')m=', as.character(signif(mean(toprt),4)),
sep=''),las=1)   # plot the historgram
botrt <- latencies[responses<0]
botprop <- length(botrt)/nreps
hist(botrt,col="gray",
xlab="Decision time",xlim=c(0,max(latencies)),
main=paste("Bottom responses (",as.numeric(botprop),
") m=",as.character(signif(mean(botrt),4)),
sep=""),las=1)
# random-walk model
nreps <- 2000    # number of trials
nsamples <- 2000  # samples to collect evidence for each decision
drift <- 0.02        # noninformative stimulus
sdrw <- 0.3          # s.t.d in the evidence
criterion <- 3      # distance between boundary and baseline
latencies <- rep (0, nreps)  # a vector to store the simulated response latencies
responses <- rep (0, nreps)  # a vector to store the simulated responses
evidence <- matrix (0, nreps, nsamples+1)  # a matrix to store the evidence for each response
for (i in c(1:nreps)) {
evidence[i ,] <- cumsum ( c ( 0 , rnorm ( nsamples , drift , sdrw ) ) )
p <- which ( abs (evidence[i, ] ) >= criterion) [1]   # find the first evidence bigger than criterion
responses[i] <- sign (evidence[i,p])    # responses: positive (left) or negative (right)
latencies[i] <- p                       # response latency
}
## plot up to 5 random-walk paths
par(mfrow=c(1 , 1))
tbpn <- min(nreps, 5)
plot(1:max(latencies[1:tbpn])+10, type='n', las = 1,
ylim = c(-criterion, criterion),
ylab = 'Evidence', xlab='Decision time')
for (i in c(1:tbpn)){
lines(evidence[i, 1:(latencies[i])])
}
abline(h=c(criterion, -criterion), lty='dashed')
## plot histograms of latencies
par(mfrow=c(2 , 1))   # to set graphical parameters (2 subplot)
toprt <- latencies[responses>0]   # response time for the left response
topprop <- length(toprt)/nreps    # probability to choose the left response
hist(toprt, col='gray',
xlab='Decision time', xlim=c(0,max(latencies)),
main=paste('Top responses (', as.numeric(topprop),')m=', as.character(signif(mean(toprt),4)),
sep=''),las=1)   # plot the historgram
botrt <- latencies[responses<0]
botprop <- length(botrt)/nreps
hist(botrt,col="gray",
xlab="Decision time",xlim=c(0,max(latencies)),
main=paste("Bottom responses (",as.numeric(botprop),
") m=",as.character(signif(mean(botrt),4)),
sep=""),las=1)
##random walk model with unequal latencies between responses classes
nreps <- 1000
nsamples <- 2000
drift <- 0.02  # 0 = noninformative stimulus; >0 = informative
sdrw <- 0.3
criterion <- 3
t2tsd  <- c(0.0, 0.025)   # trial-to-trial s.d.
latencies <- rep(0,nreps)
responses <- rep(0,nreps)
evidence <- matrix(0, nreps, nsamples+1)
for (i in c(1:nreps)) {
sp <- rnorm(1, -1, sd=t2tsd[1])      # sampling starting point: mean = 0,  std = 0
dr <- rnorm(1, drift, sd=t2tsd[2])   # sampling drift: mean = drift,  std = 0.025
evidence[i,] <- cumsum(c(sp, rnorm(nsamples, dr, sdrw)))
p <-  which(abs(evidence[i,])>criterion)[1]
responses[i] <- sign(evidence[i,p])
latencies[i]  <- p
}
#plot up to 10 random walk paths
par(mfrow=c(1,1))
tbpn <- min(nreps, 10)
plot(1:max(latencies[1:tbpn])+10,type="n",las=1,
ylim=c(-criterion-.5,criterion+.5),
ylab="Evidence",xlab="Decision time")
for (i in c(1:tbpn)) {
lines(evidence[i,1:(latencies[i])])
}
abline(h=c(criterion,-criterion),lty="dashed")
#plot histograms of latencies
par(mfrow=c(2,1))
toprt <- latencies[responses>0]
topprop <- length(toprt)/nreps
hist(toprt,col="gray",
xlab="Decision time", xlim=c(0,max(latencies)),
main=paste("Top responses (",as.numeric(topprop),
") m=",as.character(signif(mean(toprt),4)),
sep=""),las=1)
botrt <- latencies[responses<0]
botprop <- length(botrt)/nreps
hist(botrt,col="gray",
xlab="Decision time",xlim=c(0,max(latencies)),
main=paste("Bottom responses (",as.numeric(botprop),
") m=",as.character(signif(mean(botrt),4)),
sep=""),las=1)
?rnorm
rnorm ( nsamples , drift , sdrw )
rnorm ( 2000 , 0.02 , 0.1 )
# random-walk model
nreps <- 2000    # number of trials
nsamples <- 2000  # samples to collect evidence for each decision
drift <- 0.02        # noninformative stimulus
sdrw <- 0.3          # s.t.d in the evidence
criterion <- 3      # distance between boundary and baseline
latencies <- rep (0, nreps)  # a vector to store the simulated response latencies
responses <- rep (0, nreps)  # a vector to store the simulated responses
evidence <- matrix (0, nreps, nsamples+1)  # a matrix to store the evidence for each response
for (i in c(1:nreps)) {
evidence[i ,] <- cumsum ( c ( 0 , rnorm ( nsamples , drift , sdrw ) ) )
p <- which ( abs (evidence[i, ] ) >= criterion) [1]   # find the first evidence bigger than criterion
responses[i] <- sign (evidence[i,p])    # responses: positive (left) or negative (right)
latencies[i] <- p                       # response latency
}
## plot up to 5 random-walk paths
par(mfrow=c(1 , 1))
tbpn <- min(nreps, 5)
plot(1:max(latencies[1:tbpn])+10, type='n', las = 1,
ylim = c(-criterion, criterion),
ylab = 'Evidence', xlab='Decision time')
for (i in c(1:tbpn)){
lines(evidence[i, 1:(latencies[i])])
}
abline(h=c(criterion, -criterion), lty='dashed')
## plot histograms of latencies
par(mfrow=c(2 , 1))   # to set graphical parameters (2 subplot)
toprt <- latencies[responses>0]   # response time for the left response
topprop <- length(toprt)/nreps    # probability to choose the left response
hist(toprt, col='gray',
xlab='Decision time', xlim=c(0,max(latencies)),
main=paste('Top responses (', as.numeric(topprop),')m=', as.character(signif(mean(toprt),4)),
sep=''),las=1)   # plot the historgram
botrt <- latencies[responses<0]
botprop <- length(botrt)/nreps
hist(botrt,col="gray",
xlab="Decision time",xlim=c(0,max(latencies)),
main=paste("Bottom responses (",as.numeric(botprop),
") m=",as.character(signif(mean(botrt),4)),
sep=""),las=1)
## plot histograms of latencies
par(mfrow=c(2 , 1))   # to set graphical parameters (2 subplot)
toprt <- latencies[responses>0]   # response time for the left response
topprop <- length(toprt)/nreps    # probability to choose the left response
hist(toprt, col='gray',
xlab='Decision time', xlim=c(0,max(latencies)),
main=paste('Top responses (', as.numeric(topprop),')m=', as.character(signif(mean(toprt),4)),
sep=''),las=1)   # plot the historgram
botrt <- latencies[responses<0]
botprop <- length(botrt)/nreps
hist(botrt,col="gray",
xlab="Decision time",xlim=c(0,max(latencies)),
main=paste("Bottom responses (",as.numeric(botprop),
") m=",as.character(signif(mean(botrt),4)),
sep=""),las=1)
## plot histograms of latencies
par(mfrow=c(2 , 1))   # to set graphical parameters (2 subplot)
toprt <- latencies[responses>0]   # response time for the left response
topprop <- length(toprt)/nreps    # probability to choose the left response
hist(toprt, col='gray',
xlab='Decision time', xlim=c(0,max(latencies)),
main=paste('Top responses (', as.numeric(topprop),')m=', as.character(signif(mean(toprt),4)),
sep=''),las=1)   # plot the historgram
botrt <- latencies[responses<0]
botprop <- length(botrt)/nreps
hist(botrt,col="gray",
xlab="Decision time",xlim=c(0,max(latencies)),
main=paste("Bottom responses (",as.numeric(botprop),
") m=",as.character(signif(mean(botrt),4)),
sep=""),las=1)
## plot histograms of latencies
par(mfrow=c(2 , 1))   # to set graphical parameters (2 subplot)
toprt <- latencies[responses>0]   # response time for the left response
topprop <- length(toprt)/nreps    # probability to choose the left response
hist(toprt, col='gray',
xlab='Decision time', xlim=c(0,max(latencies)),
main=paste('Top responses (', as.numeric(topprop),')m=', as.character(signif(mean(toprt),4)),
sep=''),las=1)   # plot the historgram
botrt <- latencies[responses<0]
botprop <- length(botrt)/nreps
hist(botrt,col="gray",
xlab="Decision time",xlim=c(0,max(latencies)),
main=paste("Bottom responses (",as.numeric(botprop),
") m=",as.character(signif(mean(botrt),4)),
sep=""),las=1)
## plot histograms of latencies
par(mfrow=c(2 , 1))   # to set graphical parameters (2 subplot)
toprt <- latencies[responses>0]   # response time for the left response
topprop <- length(toprt)/nreps    # probability to choose the left response
hist(toprt, col='gray',
xlab='Decision time', xlim=c(0,max(latencies)),
main=paste('Top responses (', as.numeric(topprop),')m=', as.character(signif(mean(toprt),4)),
sep=''),las=1)   # plot the historgram
botrt <- latencies[responses<0]
botprop <- length(botrt)/nreps
hist(botrt,col="gray",
xlab="Decision time",xlim=c(0,max(latencies)),
main=paste("Bottom responses (",as.numeric(botprop),
") m=",as.character(signif(mean(botrt),4)),
sep=""),las=1)
par(mfrow=c(1 , 1))   # to set graphical parameters (2 subplot)
toprt <- latencies[responses>0]   # response time for the left response
topprop <- length(toprt)/nreps    # probability to choose the left response
hist(toprt, col='gray',
xlab='Decision time', xlim=c(0,max(latencies)),
main=paste('Top responses (', as.numeric(topprop),')m=', as.character(signif(mean(toprt),4)),
sep=''),las=1)   # plot the historgram
par(mfrow=c(1 , 1))
botrt <- latencies[responses<0]
botprop <- length(botrt)/nreps
hist(botrt,col="gray",
xlab="Decision time",xlim=c(0,max(latencies)),
main=paste("Bottom responses (",as.numeric(botprop),
") m=",as.character(signif(mean(botrt),4)),
sep=""),las=1)
?cumsum
?t.test
?t.test2
?t2.test
botrt <- latencies[responses<0]
toprt <- latencies[responses>0]
t.test(botrt, toprt)
# random-walk model
nreps <- 2000    # number of trials
nsamples <- 2000  # samples to collect evidence for each decision
drift <- 0.02        # noninformative stimulus
sdrw <- 0.3          # s.t.d in the evidence
criterion <- 3      # distance between boundary and baseline
latencies <- rep (0, nreps)  # a vector to store the simulated response latencies
responses <- rep (0, nreps)  # a vector to store the simulated responses
evidence <- matrix (0, nreps, nsamples+1)  # a matrix to store the evidence for each response
for (i in c(1:nreps)) {
evidence[i ,] <- cumsum ( c ( 0 , rnorm ( nsamples , drift , sdrw ) ) )
p <- which ( abs (evidence[i, ] ) >= criterion) [1]   # find the first evidence bigger than criterion
responses[i] <- sign (evidence[i,p])    # responses: positive (left) or negative (right)
latencies[i] <- p                       # response latency
}
botrt <- latencies[responses<0]
toprt <- latencies[responses>0]
t.test(botrt,toprt)
#plot data and current predictions
getregpred <- function(parms, data) {
getregpred <- parms["b0"] + parms["b1"]*data[ ,2]
# #wait with drawing a graph until key is pressed
# par(ask=TRUE)
# plot   (data[ ,2], type="n", las=1, ylim=c(-2,2), xlim=c(-2,2), xlab="X", ylab="Y")
# par(ask=FALSE)
# points (data[ ,2], data[ ,1], pch=21, bg="gray")
# lines  (data[ ,2], getregpred, lty="solid")
#
# return(getregpred)
}
#obtain current predictions and compute discrepancy
rmsd <- function(parms, data1) {
preds <- getregpred(parms, data1)  # parms["b0"] + parms["b1"]*data[ ,2]
rmsd  <- sqrt(sum((preds-data1[ ,1])^2)/length(preds))  # calculate RMSD
}
#define parameters to generate data
nDataPts  <- 20
rho       <- 0.8
intercept <- 0.0
#generate synthetic data
data <- matrix(0,nDataPts,2)
data[ ,2] <- rnorm(nDataPts)     # x, data, independent variable
data[ ,1] <- rnorm(nDataPts)*sqrt(1.0-rho^2) + data[ ,2]*rho + intercept  # y, output
#do conventional regression analysis
lm1 = lm(data[,1] ~ data[,2])    # lm(y ~ x)
summary(lm1)
#assign starting values
startParms <- c(-1., .2)
names(startParms) <- c("b1", "b0")
#obtain parameter estimates using default Simplex method
xout <- optim(startParms, rmsd, data1=data)
#obtain parameter estimates using Simulated Annealing
xout <- optim(startParms, rmsd, data1=data, method='Nelder-Mead')
xout
#plot data and current predictions
getregpred <- function(parms, data) {
getregpred <- parms["b0"] + parms["b1"]*data[ ,2]
# #wait with drawing a graph until key is pressed
# par(ask=TRUE)
# plot   (data[ ,2], type="n", las=1, ylim=c(-2,2), xlim=c(-2,2), xlab="X", ylab="Y")
# par(ask=FALSE)
# points (data[ ,2], data[ ,1], pch=21, bg="gray")
# lines  (data[ ,2], getregpred, lty="solid")
#
# return(getregpred)
}
#obtain current predictions and compute discrepancy
rmsd <- function(parms, data1) {
preds <- getregpred(parms, data1)  # parms["b0"] + parms["b1"]*data[ ,2]
rmsd  <- sqrt(sum((preds-data1[ ,1])^2)/length(preds))  # calculate RMSD
}
#define parameters to generate data
nDataPts  <- 20
rho       <- 0.8
intercept <- 0.0
#generate synthetic data
data <- matrix(0,nDataPts,2)
data[ ,2] <- rnorm(nDataPts)     # x, data, independent variable
data[ ,1] <- rnorm(nDataPts)*sqrt(1.0-rho^2) + data[ ,2]*rho + intercept  # y, output
#do conventional regression analysis
lm1 = lm(data[,1] ~ data[,2])    # lm(y ~ x)
summary(lm1)
#assign starting values
startParms <- c(-1., .2)
names(startParms) <- c("b1", "b0")
#obtain parameter estimates using default Simplex method
xout <- optim(startParms, rmsd, data1=data)
#obtain parameter estimates using Simulated Annealing
xout <- optim(startParms, rmsd, data1=data, method='Nelder-Mead')
xout
install.packages("lavaan")
install.packages("semPlot")
library(lavaan)
library(semPlot)
library(dplyr)
lvsem_sem <- read.csv(file="SEM_for_uwcb.csv", header=T)
#perform MCMC with Uniform prior
burnin<-200
chain <- rep(0,5000)
obs <- 144      # observed data
propsd <- 2    # tuning parameter
chain[1] <- 150  #starting value
for (i in 2:length(chain)) {
current <- chain[i-1]
proposal <- current + rnorm(1,0,propsd)
if (dnorm(obs,proposal,15) > dnorm(obs,current,15)) {
chain[i] <- proposal  #accept proposal
} else {
chain[i] <- ifelse(runif(1) < dnorm(obs,proposal,15)/dnorm(obs,current,15),
proposal,
current)
}
}
# x11(5,10)
# hist(chain)
mean(chain)
x11(5,10)
plot(density(chain),las=1,xlab=bquote("Sampled values of "*mu),
yaxt="n",lwd=2,lty="dashed",
main="",xlim=c(100,200),ylab="",
ylim=c(0,max(max(density(chain)$y),
max(density(chain[-c(1:burnin)])$y),
max(dnorm(c(100:200),144,15)))*1.4))
lines(density(chain[-c(1:burnin)]),lwd=2,lty="solid")
lines(c(100:200),dnorm(c(100:200),144,15),col="red",lwd=2)
mtext("   Density",2,1)
legend("topright",inset=.02,c("Normal PDF","All MCMC","Excluding burnin"),
lty=c("solid","dashed","solid"),col=c("red","black","black"),lwd=2)
x11(5,10)
plot(chain,type="l",las=1,xlab="Iteration",ylab="Value of accepted sample")
lines(1:burnin,chain[1:burnin],col="red")
?runif
mean(chain)
library(rjags)
#generate data z
rho <- .8
mux  <- muy <- 0
sigx <- 1
sigy <- .5
sigma <- matrix(c(sigx^2, rho*sigx*sigy, rho*sigy*sigx, sigy^2),
nrow=2)
N = 50
z <- rmvnorm(50, c(mux, muy), sigma)
#define JAGS model
hw3_model <- jags.model("hw3.j",
data = list("z"=z, "N" = N),
n.chains=4)
# burnin
update(hw3_model, n.iter=1000)
# perform MCMC
parameters <- c("sig1", "sig2", "rho")
mcmcfin<-coda.samples(hw3_model, parameters, 5000)
library(rjags)
setwd('/Users/huahua/Documents/ML&NeuroEngineering 2021/11 - Gibbs Sampling & JAGS/R_code_11')
#generate data z
rho <- .8
mux  <- muy <- 0
sigx <- 1
sigy <- .5
sigma <- matrix(c(sigx^2, rho*sigx*sigy, rho*sigy*sigx, sigy^2),
nrow=2)
N = 50
z <- rmvnorm(50, c(mux, muy), sigma)
#define JAGS model
hw3_model <- jags.model("hw3.j",
data = list("z"=z, "N" = N),
n.chains=4)
# burnin
update(hw3_model, n.iter=1000)
# perform MCMC
parameters <- c("sig1", "sig2", "rho")
mcmcfin<-coda.samples(hw3_model, parameters, 5000)
library(rjags)
setwd('/Users/huahua/Documents/ML&NeuroEngineering 2021/11 - Gibbs Sampling & JAGS/R_code_11/')
#generate data z
rho <- .8
mux  <- muy <- 0
sigx <- 1
sigy <- .5
sigma <- matrix(c(sigx^2, rho*sigx*sigy, rho*sigy*sigx, sigy^2),
nrow=2)
N = 50
z <- rmvnorm(50, c(mux, muy), sigma)
#define JAGS model
hw3_model <- jags.model("hw3.j",
data = list("z"=z, "N" = N),
n.chains=4)
# burnin
update(hw3_model, n.iter=1000)
# perform MCMC
parameters <- c("sig1", "sig2", "rho")
mcmcfin<-coda.samples(hw3_model, parameters, 5000)
library(rjags)
require(mvtnorm)
setwd('/Users/huahua/Documents/ML&NeuroEngineering 2021/11 - Gibbs Sampling & JAGS/R_code_11/')
#generate data z
rho <- .8
mux  <- muy <- 0
sigx <- 1
sigy <- .5
sigma <- matrix(c(sigx^2, rho*sigx*sigy, rho*sigy*sigx, sigy^2),
nrow=2)
N = 50
z <- rmvnorm(50, c(mux, muy), sigma)
#define JAGS model
hw3_model <- jags.model("hw3.j",
data = list("z"=z, "N" = N),
n.chains=4)
# burnin
update(hw3_model, n.iter=1000)
# perform MCMC
parameters <- c("sig1", "sig2", "rho")
mcmcfin<-coda.samples(hw3_model, parameters, 5000)
summary(mcmcfin)
plot(mcmcfin)
